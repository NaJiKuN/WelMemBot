import logging
import os
import signal
import sys
from datetime import datetime, timedelta
from pathlib import Path
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, Filters, CallbackQueryHandler
from telegram.error import TelegramError
import random
import string
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# Load environment variables
load_dotenv()

# Bot settings
BOT_TOKEN = os.getenv("BOT_TOKEN")
BOT_USERNAME = "WelMemBot"
ADMIN_IDS = [764559466]  # Admin ID
INVITE_LINK = "https://t.me/+BgsrjW-Y8qtkOTY0"  # Group invite link
WELCOME_MESSAGE = """
Welcome, {username}!
Your membership will automatically expire after 1 month.
Please adhere to the group rules and avoid leaving before the specified period to prevent membership suspension.
"""
DB_PATH = Path(__file__).parent / "invite_codes.db"
DB_URL = f"sqlite:///{DB_PATH}"

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Database setup with SQLAlchemy
Base = declarative_base()

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    code = Column(String, primary_key=True)
    used = Column(Boolean, default=False)
    used_by = Column(Integer)
    used_at = Column(DateTime)
    expires_at = Column(DateTime)

class GroupSettings(Base):
    __tablename__ = 'group_settings'
    id = Column(Integer, primary_key=True)
    group_id = Column(Integer)
    group_name = Column(String)

class Member(Base):
    __tablename__ = 'members'
    user_id = Column(Integer, primary_key=True)
    username = Column(String)
    first_name = Column(String)
    last_name = Column(String)
    joined_at = Column(DateTime)
    expires_at = Column(DateTime)

def init_db():
    engine = create_engine(DB_URL, connect_args={"check_same_thread": False})
    Base.metadata.create_all(engine)
    # Create indexes for performance
    from sqlalchemy import text
    with engine.connect() as conn:
        conn.execute(text("CREATE INDEX IF NOT EXISTS idx_code ON invite_codes(code)"))
        conn.execute(text("CREATE INDEX IF NOT EXISTS idx_user_id ON members(user_id)"))
    return engine

engine = init_db()
Session = sessionmaker(bind=engine)

# Admin check
def is_admin(user_id):
    return user_id in ADMIN_IDS

# Helper functions
def generate_random_code():
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

# Bot handlers
async def start(update: Update, context):
    if is_admin(update.effective_user.id):
        keyboard = [
            [InlineKeyboardButton("Generate Invite Codes", callback_data='generate_codes')],
            [InlineKeyboardButton("Set Group", callback_data='set_group')],
            [InlineKeyboardButton("Show Statistics", callback_data='show_stats')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text('Admin Panel - Please choose an option:', reply_markup=reply_markup)
    else:
        await update.message.reply_text('Hello! To join the group, please enter your invite code.')

async def admin_command(update: Update, context):
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("â›” Access denied.")
        return
    
    keyboard = [
        [InlineKeyboardButton("Generate Invite Codes", callback_data='generate_codes')],
        [InlineKeyboardButton("Set Group", callback_data='set_group')],
        [InlineKeyboardButton("Show Statistics", callback_data='show_stats')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text('Admin Dashboard:', reply_markup=reply_markup)

async def set_group(update: Update, context):
    query = update.callback_query
    if not is_admin(query.from_user.id):
        await query.answer("â›” Access denied.")
        return
    
    await query.answer()
    await query.edit_message_text(text="Please send the group ID and name in this format:\n/group 12345678 GroupName")

async def handle_group_id(update: Update, context):
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("â›” Access denied.")
        return
    
    try:
        parts = update.message.text.split()
        if len(parts) < 3 or not parts[1].isdigit():
            await update.message.reply_text("Invalid format. Please use: /group 12345678 GroupName")
            return
        
        group_id = int(parts[1])
        group_name = ' '.join(parts[2:])
        
        # Check if bot has admin permissions
        try:
            bot_member = await context.bot.get_chat_member(group_id, context.bot.id)
            if not bot_member.can_send_messages:
                await update.message.reply_text("Error: Bot does not have permission to send messages in this group.")
                return
        except TelegramError as e:
            logger.error(f"Error checking bot permissions for group {group_id}: {str(e)}")
            await update.message.reply_text("Error: Unable to verify bot permissions in the group.")
            return

        with Session() as session:
            group = session.query(GroupSettings).filter_by(id=1).first()
            if not group:
                group = GroupSettings(id=1, group_id=group_id, group_name=group_name)
            else:
                group.group_id = group_id
                group.group_name = group_name
            session.add(group)
            session.commit()
        
        await update.message.reply_text(f"Group set successfully!\nID: {group_id}\nName: {group_name}")
    except Exception as e:
        logger.error(f"Error setting group: {str(e)}")
        await update.message.reply_text(f"Error setting group: {str(e)}")

async def generate_codes(update: Update, context):
    query = update.callback_query
    if not is_admin(query.from_user.id):
        await query.answer("â›” Access denied.")
        return
    
    await query.answer()
    await query.edit_message_text(text="How many invite codes would you like to generate? Please send a number.")

async def handle_code_count(update: Update, context):
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("â›” Access denied.")
        return
    
    try:
        count = int(update.message.text)
        if count <= 0 or count > 100:
            await update.message.reply_text("Please enter a number between 1 and 100.")
            return
        
        codes = []
        with Session() as session:
            for _ in range(count):
                code = generate_random_code()
                expires_at = datetime.now() + timedelta(days=30)
                invite_code = InviteCode(code=code, expires_at=expires_at)
                session.add(invite_code)
                codes.append(code)
            session.commit()
        
        await update.message.reply_text(f"âœ… Generated {count} invite codes (valid for 30 days):\n\n" + "\n".join(codes))
    except ValueError:
        await update.message.reply_text("Please enter a valid number.")
    except SQLAlchemyError as e:
        logger.error(f"Error generating codes: {str(e)}")
        await update.message.reply_text("Error generating codes. Please try again later.")

async def show_stats(update: Update, context):
    query = update.callback_query
    if not is_admin(query.from_user.id):
        await query.answer("â›” Access denied.")
        return
    
    try:
        with Session() as session:
            total_codes = session.query(InviteCode).count()
            used_codes = session.query(InviteCode).filter_by(used=True).count()
            total_members = session.query(Member).count()
            group = session.query(GroupSettings).filter_by(id=1).first()
            group_info = f"Current group: {group.group_name} (ID: {group.group_id})" if group else "No group set yet"
        
        await query.answer()
        await query.edit_message_text(
            text=f"ðŸ“Š Bot Statistics:\n\n"
                 f"â€¢ Total codes: {total_codes}\n"
                 f"â€¢ Used codes: {used_codes}\n"
                 f"â€¢ Available codes: {total_codes - used_codes}\n"
                 f"â€¢ Total members: {total_members}\n\n"
                 f"{group_info}"
        )
    except SQLAlchemyError as e:
        logger.error(f"Error fetching stats: {str(e)}")
        await query.edit_message_text("Error fetching statistics. Please try again later.")

async def handle_invite_code(update: Update, context):
    user_code = update.message.text.upper().strip()
    user = update.effective_user
    
    try:
        with Session() as session:
            code = session.query(InviteCode).filter_by(code=user_code).first()
            if not code or code.used or code.expires_at < datetime.now():
                await update.message.reply_text("âŒ Invalid or expired invite code. Please check and try again.")
                return
            
            group = session.query(GroupSettings).filter_by(id=1).first()
            if not group:
                await update.message.reply_text("Group not set yet. Please contact the admin.")
                return
            
            # Check if user is already in the group
            try:
                member = await context.bot.get_chat_member(group.group_id, user.id)
                if member.status in ['member', 'administrator', 'creator']:
                    await update.message.reply_text("You are already a member of the group!")
                    return
            except TelegramError:
                pass  # User not in group, proceed with code usage
            
            # Mark code as used
            code.used = True
            code.used_by = user.id
            code.used_at = datetime.now()
            
            # Add member to database
            member = Member(
                user_id=user.id,
                username=user.username,
                first_name=user.first_name,
                last_name=user.last_name,
                joined_at=datetime.now(),
                expires_at=datetime.now() + timedelta(days=30)
            )
            session.add(member)
            session.commit()
        
        # Send success message to user
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"âœ… Invite code verified successfully!\n\n"
                 f"Click the link below to join our group:\n"
                 f"{INVITE_LINK}\n\n"
                 f"We look forward to having you with us!"
        )
        
        # Send welcome message to group
        welcome_msg = WELCOME_MESSAGE.format(
            username=user.username or user.first_name or "New Member"
        )
        await context.bot.send_message(
            chat_id=group.group_id,
            text=welcome_msg
        )
        
    except TelegramError as e:
        logger.error(f"Telegram error processing code {user_code} for user {user.id}: {str(e)}")
        await update.message.reply_text("Error processing invite code. Please try again later.")
    except SQLAlchemyError as e:
        logger.error(f"Database error processing code {user_code} for user {user.id}: {str(e)}")
        await update.message.reply_text("Database error. Please try again later.")

async def error_handler(update: Update, context):
    logger.error(f"Update {update} caused error {context.error}")
    if update and update.effective_message:
        await update.effective_message.reply_text("An error occurred. Please try again later.")

async def check_expired_members(context):
    try:
        with Session() as session:
            expired_members = session.query(Member).filter(Member.expires_at < datetime.now()).all()
            group = session.query(GroupSettings).filter_by(id=1).first()
            if not group:
                return
            
            for member in expired_members:
                try:
                    await context.bot.ban_chat_member(group.group_id, member.user_id)
                    session.delete(member)
                    logger.info(f"Removed expired member {member.user_id} from group {group.group_id}")
                except TelegramError as e:
                    logger.error(f"Error removing member {member.user_id}: {str(e)}")
            session.commit()
    except SQLAlchemyError as e:
        logger.error(f"Error checking expired members: {str(e)}")

def shutdown(signum, frame):
    logger.info("Shutting down bot...")
    scheduler.shutdown()
    engine.dispose()
    sys.exit(0)

def main():
    global scheduler
    # Initialize scheduler for checking expired members
    scheduler = AsyncIOScheduler()
    scheduler.add_job(check_expired_members, 'interval', hours=24, args=[None])
    scheduler.start()

    # Handle graceful shutdown
    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)

    # Initialize bot
    app = Application.builder().token(BOT_TOKEN).build()

    # Handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_command))
    app.add_handler(CommandHandler("group", handle_group_id))
    app.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_invite_code))
    app.add_handler(MessageHandler(Filters.regex(r'^\d+$') & Filters.chat(chat_id=ADMIN_IDS), handle_code_count))
    app.add_handler(CallbackQueryHandler(generate_codes, pattern='generate_codes'))
    app.add_handler(CallbackQueryHandler(set_group, pattern='set_group'))
    app.add_handler(CallbackQueryHandler(show_stats, pattern='show_stats'))
    app.add_error_handler(error_handler)

    app.run_polling()
    logger.info("Bot is running...")

if __name__ == '__main__':
    main()
